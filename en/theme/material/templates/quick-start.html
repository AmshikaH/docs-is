<!--
 * Copyright (c) 2024, WSO2 LLC. (https://www.wso2.com).
 *
 * WSO2 LLC. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
-->

{% extends "base.html" %}

{% block styles %}
  {{ super() }}
  <link rel="stylesheet" href="{{ 'assets/css/quick-start.css' | url }}">
{% endblock %}

{% block container %}
  <div class="md-content" data-md-component="content">
    <article class="md-content__inner md-typeset">

      {{ page.content }}

    </article>
  </div>

  <script>

    const basePath = {{ config.extra.base_path | tojson }};
    const product = {{ config.extra.product | tojson }};
    const productName = {{ config.extra.product_name | tojson }};

    const stepContentStart = Array.from(document.querySelectorAll("p")).find(p => p.textContent.trim() === "[//] STEPS_START");
    const stepContentEnd = Array.from(document.querySelectorAll("p")).find(p => p.textContent.trim() === "[//] STEPS_END");

    /**
      * This script render a summary box with "What's Next?" section.
      * It uses the meta object to populate the content dynamically.
      */

    function renderWhatsNext(meta) {
      if (!meta || !meta.whats_next) return '';

      {% raw %}
      const replaceTokens = (text) =>
        text
          .replace(/{{\s*base_path\s*}}/g, basePath)
          .replace(/{{\s*product\s*}}/g, product)
          .replace(/{{\s*product_name\s*}}/g, productName);
      {% endraw %}

      const renderList = (items) => items.map(item => `<li>${replaceTokens(item)}</li>`).join('');

      return `
        <div class="whats-new">
          <h2>What's Next?</h2>
          <ul>
            ${renderList(meta.whats_next)}
          </ul>
        </div>`;
    }

    /**
      * This script render a summary box with "What You Will Learn",
      * "Prerequisites", and "Example Source Code" sections.
      * It uses the meta object to populate the content dynamically.
      */

    function renderSummaryBox(meta) {
      if (!meta || (!meta.what_you_will_learn && !meta.prerequisites && !meta.source_code)) return '';

      {% raw %}
      const replaceTokens = (text) =>
        text
          .replace(/{{\s*base_path\s*}}/g, basePath)
          .replace(/{{\s*product\s*}}/g, product)
          .replace(/{{\s*product_name\s*}}/g, productName);
      {% endraw %}

      const renderList = (items) => items.map(item => `<li>${replaceTokens(item)}</li>`).join('');

      let html = `<div class="summary-box">`;

      if (meta.what_you_will_learn || meta.prerequisites) {
        html += `<div class="flex-container">`;

        if (meta.what_you_will_learn) {
          html += `
            <div class="column left">
              <h4 id="what-you-will-learn">What You Will Learn</h4>
              <ul class="tick-list">
                ${renderList(meta.what_you_will_learn)}
              </ul>
            </div>`;
        }

        if (meta.prerequisites) {
          html += `
            <div class="column right">
              <h4>Prerequisites</h4>
              Before you start, ensure you have the following:
              <ul>
                ${renderList(meta.prerequisites)}
              </ul>
            </div>`;
        }

        html += `</div>`;
      }

      if (meta.source_code) {
        html += `
          <h4>Example Source Code</h4>
          ${meta.source_code}
        `;
      }

      html += `</div>`;

      return html;
    }

    /**
      * This script processes the content of the page to wrap STEPS sections to style with numbering.
      * It identifies sections based on H2 tags and wraps them in divs with unique IDs.
      * Elements bettween !! STEPS_START !! and !! STEPS_END !! will be processed.
      */
    
    let currentElement = stepContentStart.nextElementSibling;

    const siblings = [];

    let newSection = [];
    let updatedContent = [];
    let sectionCount = 0; // Counter for unique IDs
    
    // Function to wrap an element
    function wrapElement(targetElements, wrapperElement) {
        // Move all target elements inside the wrapper
        targetElements.forEach(item => wrapperElement.appendChild(item));
    }
    
    // Loop through sibling elements
    while (currentElement && currentElement !== stepContentEnd) {
      // Store the current element in the array
      siblings.push(currentElement);
      
      // Store the next sibling before removing the current one
      const nextElement = currentElement.nextElementSibling;
      
      // Remove the current element from the DOM
      currentElement.remove();
      
      // Move to the next element
      currentElement = nextElement;
    }
    
    // Process siblings to wrap them and prepend numbers to H2 tags
    siblings.forEach(function(element) {
      if (element.nodeName === 'SCRIPT') {
          // Skip SCRIPT tag
          return;
      }

      if (element.nodeName === 'H2') {
          // Check if this step has conditional rendering requirements first
          const headingText = element.textContent || element.innerText;
          const showIfMatch = headingText.match(/\[\/\/\] SHOW_IF="([^"]+)"/);
          
          if (newSection.length > 0) {
              // Create a wrapper for the current section
              const wrapper = document.createElement('div');
              
              // Assign a unique ID and data attributes to the wrapper
              wrapper.id = `step-${sectionCount}`;
              wrapper.setAttribute('data-step', 'true');
              wrapper.setAttribute('data-step-id', sectionCount);
              wrapper.className = 'step'; // Keep class for CSS styling
              
              // Check if any element in newSection has conditional data
              const conditionalElement = newSection.find(el => el.getAttribute && el.getAttribute('data-pending-show-if'));
              if (conditionalElement) {
                  const conditions = conditionalElement.getAttribute('data-pending-show-if');
                  wrapper.setAttribute('data-show-if', conditions);
                  conditionalElement.removeAttribute('data-pending-show-if');
              }
  
              // Wrap the newSection elements
              wrapElement(newSection, wrapper);
  
              // Store the wrapped element
              updatedContent.push(wrapper);
  
              // Clear the newSection for the next group
              newSection = [];
          }
          
          // Increment section count
          sectionCount++; 
  
          // Create a span for the section number
          const span = document.createElement('span');
          span.textContent = sectionCount; // Set the text content to the section number
          span.setAttribute('data-step-number', 'true');
          span.className = 'step-number'; // Keep class for CSS styling
          
          // Store conditional marker in data attribute but don't clean heading text yet
          if (showIfMatch) {
              // Store the conditions in a data attribute for the wrapper (which will be created next)
              element.setAttribute('data-pending-show-if', showIfMatch[1]);
          }
          
          // Prepend the span to the H2 element
          element.insertAdjacentElement('afterbegin', span);
      }
  
      // Add the current element to the new section
      newSection.push(element);
    });
    
    // Handle any remaining elements after the last H2
    if (newSection.length > 0) {
      const wrapper = document.createElement('div');
      
      // Assign a unique ID and data attributes to the wrapper
      wrapper.id = `step-${sectionCount}`;
      wrapper.setAttribute('data-step', 'true');
      wrapper.setAttribute('data-step-id', sectionCount);
      wrapper.className = 'step'; // Keep class for CSS styling
      
      // Check if any element in newSection has conditional data
      const conditionalElement = newSection.find(el => el.getAttribute && el.getAttribute('data-pending-show-if'));
      if (conditionalElement) {
          const conditions = conditionalElement.getAttribute('data-pending-show-if');
          wrapper.setAttribute('data-show-if', conditions);
          conditionalElement.removeAttribute('data-pending-show-if');
      }
  
      // Wrap the remaining elements
      wrapElement(newSection, wrapper);
      updatedContent.push(wrapper);
    }

    const sectionsWrapper = document.createElement('div');
                
    // Assign a unique ID and class to the wrapper
    sectionsWrapper.id = "steps-section";
    sectionsWrapper.className = 'steps-section'; // Add your class here

    stepContentStart.insertAdjacentElement('afterend', sectionsWrapper);
    
    // Insert the new elements after the stepContentStart element
    updatedContent.forEach(content => {
      sectionsWrapper.appendChild(content);
    });

    // Add "What's Next?" section
    stepContentEnd.insertAdjacentHTML("afterend", renderWhatsNext(meta));
    // Add summary box section
    stepContentStart.insertAdjacentHTML("afterend", renderSummaryBox(meta));

    // Remove the original STEPS_START and STEPS_END markers
    stepContentStart.remove();
    stepContentEnd.remove();
    
    // Clean up conditional markers from headings now that data attributes are set
    function cleanupConditionalMarkers() {
      const allSteps = document.querySelectorAll('[data-step]');
      allSteps.forEach(step => {
        const heading = step.querySelector('h2');
        if (heading && step.getAttribute('data-show-if')) {
          const headingText = heading.textContent || heading.innerText;
          if (headingText.includes('[//] SHOW_IF=')) {
            const stepNumberSpan = heading.querySelector('[data-step-number]');
            const cleanHeading = headingText
              .replace(/\s*\[\/\/\] SHOW_IF="[^"]+"\s*/, '')
              .replace(/¶/g, '')  // Remove permalink symbols
              .replace(/^\d+/, '')  // Remove leading numbers
              .trim();
            
            // Clean up the heading ID by removing the conditional marker part
            const currentId = heading.id;
            const cleanId = currentId.replace(/-show_if[^-]*$/i, '').replace(/-show_if.*$/, '');
            heading.id = cleanId;
            
            // Clear the heading content and rebuild it
            heading.innerHTML = '';
            if (stepNumberSpan) {
              heading.appendChild(stepNumberSpan);
            }
            
            // Add the clean text as a text node
            const textNode = document.createTextNode(cleanHeading);
            heading.appendChild(textNode);
            
            // Re-add the permalink with the clean ID
            const permalink = document.createElement('a');
            permalink.className = 'headerlink';
            permalink.href = '#' + cleanId;
            permalink.title = 'Permanent link';
            permalink.innerHTML = '¶';
            heading.appendChild(permalink);
          }
        }
      });
    }
    
    cleanupConditionalMarkers();

    /**
      * Handle conditional step rendering based on selection buttons
      */
    function handleConditionalSteps() {
      // Find all selection containers using data attribute
      const selectionContainers = document.querySelectorAll('[data-selection-group]');
      
      selectionContainers.forEach(container => {
        const groupType = container.getAttribute('data-selection-group');
        const selectionButtons = container.querySelectorAll(`[data-${groupType}]`);
        
        if (selectionButtons.length > 0) {
          const dataAttributeType = `data-${groupType}`;
          
          // Initially hide all conditional steps
          hideAllConditionalSteps();

          selectionButtons.forEach(button => {
            button.addEventListener('click', function() {
              const selectedValue = this.getAttribute(dataAttributeType);
              const stepToNavigate = this.getAttribute('data-next-step');
              
              // Remove active state from all buttons in this container and uncheck radio buttons
              selectionButtons.forEach(btn => {
                btn.removeAttribute('data-active');
                btn.classList.remove('active'); // Keep for CSS compatibility
                const radio = btn.querySelector('[data-selection-radio]');
                if (radio) radio.checked = false;
              });
              
              // Add active state to clicked button and check its radio button
              this.setAttribute('data-active', 'true');
              this.classList.add('active'); // Keep for CSS compatibility
              const thisRadio = this.querySelector('[data-selection-radio]');
              if (thisRadio) thisRadio.checked = true;
              
              // Handle dynamic content visibility based on selection value
              handleDynamicContentVisibility(dataAttributeType, selectedValue);
              
              // Hide all conditional steps first
              hideAllConditionalSteps();
              
              // Show steps that match the selected value
              const conditionToPass = `${dataAttributeType}=${selectedValue}`;
              showStepsForSelection(conditionToPass);
              
              // Update the step numbering and TOC
              updateStepNumbering();
            });
          });

          // Also handle direct radio button clicks
          const radios = container.querySelectorAll('[data-selection-radio]');
          radios.forEach(radio => {
            radio.addEventListener('change', function() {
              if (this.checked) {
                // Find the parent button and trigger its click
                const parentButton = this.closest(`[data-${groupType}]`);
                if (parentButton) {
                  parentButton.click();
                }
              }
            });
          });

          // Set default selection (button with data-default="true" or first button)
          const defaultButton = container.querySelector('[data-default="true"]') || selectionButtons[0];
          if (defaultButton) {
            // Use setTimeout to ensure TOC is ready
            setTimeout(() => {
              defaultButton.click();
            }, 100);
          }
        }
      });
    }

    /**
     * Handle dynamic content visibility based on selection
     */
    function handleDynamicContentVisibility(dataAttributeType, selectedValue) {
      // Handle data attribute-based content elements
      const dataBasedElements = document.querySelectorAll(`[data-content-for]`);
      dataBasedElements.forEach(element => {
        const contentFor = element.getAttribute('data-content-for');
        const contentValue = element.getAttribute('data-content-value');
        
        // Check if this element corresponds to the current selection type
        if (dataAttributeType === `data-${contentFor}`) {
          if (contentValue === selectedValue) {
            element.style.display = 'block';
          } else {
            element.style.display = 'none';
          }
        }
      });
    }

    /**
     * Hide all conditional steps
     */
    function hideAllConditionalSteps() {
      const allSteps = document.querySelectorAll('[data-step]');
      
      allSteps.forEach(step => {
        // Check if this step has conditional rendering requirements
        const hasConditions = step.getAttribute('data-show-if');
        
        if (hasConditions) {
          step.style.display = 'none';
        }
      });
    }

    /**
     * Show steps that match the selected value
     */
    function showStepsForSelection(selectedCondition) {
      const allSteps = document.querySelectorAll('[data-step]');
      
      allSteps.forEach(step => {
        const conditions = step.getAttribute('data-show-if');
        
        if (conditions) {
          const conditionList = conditions.split(',').map(c => c.trim());
          
          // Show step if the selected condition is in the conditions
          if (conditionList.includes(selectedCondition)) {
            step.style.display = 'block';
          } else {
            step.style.display = 'none';
          }
        } else {
          // Steps without conditional markers are always visible
          step.style.display = 'block';
        }
      });
    }

    /**
     * Update step numbering after conditional content is shown/hidden
     */
    function updateStepNumbering() {
      // Get all visible steps
      const allSteps = document.querySelectorAll('[data-step]');
      const visibleSteps = Array.from(allSteps).filter(step => {
        return step.style.display !== 'none';
      });
      
      // Renumber visible steps
      visibleSteps.forEach((step, index) => {
        const stepNumber = step.querySelector('[data-step-number]');
        if (stepNumber) {
          stepNumber.textContent = index + 1;
        }
      });
      
      // Update TOC numbering for visible steps
      updateTOCForVisibleSteps(visibleSteps);
    }

    /**
     * Update TOC to show only visible steps
     */
    function updateTOCForVisibleSteps(visibleSteps) {
      const tocLinks = document.querySelectorAll('.md-sidebar--secondary [data-md-component="toc"] a');
      let visibleStepIndex = 1;
      
      tocLinks.forEach((link) => {
        const href = link.getAttribute('href');
        if (href && href.startsWith('#')) {
          // Check if this TOC link has conditional markers in its text or stored data
          const linkText = link.textContent || link.innerText;
          let conditions = link.getAttribute('data-toc-conditions');
          
          if (!conditions) {
            // First time processing - extract conditions from text
            const showIfMatch = linkText.match(/\[\/\/\] SHOW_IF="([^"]+)"/);
            if (showIfMatch) {
              conditions = showIfMatch[1];
              // Store conditions in data attribute for future use
              link.setAttribute('data-toc-conditions', conditions);
              
              // Clean up the text by removing the conditional marker
              const cleanText = linkText.replace(/\s*\[\/\/\] SHOW_IF="[^"]+"\s*/, '');
              // Find text nodes and update them, preserving the span element
              const textNodes = Array.from(link.childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
              textNodes.forEach(textNode => {
                const nodeText = textNode.textContent;
                const cleanNodeText = nodeText.replace(/\s*\[\/\/\] SHOW_IF="[^"]+"\s*/, '');
                if (nodeText !== cleanNodeText) {
                  textNode.textContent = cleanNodeText;
                }
              });
            }
          }
          
          let isVisible = true;
          
          if (conditions) {
            // This TOC link has conditional requirements
            const conditionList = conditions.split(',').map(c => c.trim());
            
            // Find any active selection button to determine current selection
            const activeButtons = document.querySelectorAll('[data-active="true"], .selection-btn.active, .mode-selection-btn.active');
            let currentSelection = 'data-quickstart-mode=redirect'; // default fallback
            
            if (activeButtons.length > 0) {
              const activeButton = activeButtons[0];
              // Extract the data attribute type and value
              const dataAttributes = Array.from(activeButton.attributes)
                .filter(attr => attr.name.startsWith('data-') && attr.name !== 'data-show-if' && attr.name !== 'data-active');
              
              if (dataAttributes.length > 0) {
                const dataAttr = dataAttributes[0];
                currentSelection = `${dataAttr.name}=${dataAttr.value}`;
              }
            }
            
            isVisible = conditionList.includes(currentSelection);
          }
          
          if (isVisible) {
            // Update step number if this link has a step number span
            const tocStepNumber = link.querySelector('[data-toc-step-number]');
            if (tocStepNumber) {
              tocStepNumber.textContent = visibleStepIndex;
              visibleStepIndex++;
            }
            
            link.style.display = '';
            link.parentElement.style.display = '';
          } else {
            link.style.display = 'none';
            link.parentElement.style.display = 'none';
          }
        }
      });
    }

    // Initialize conditional steps handling
    handleConditionalSteps();
    
  </script>
  <script>

    const toc = document.querySelector('.md-sidebar--secondary [data-md-component="toc"]');

    // Initialize the section count
    let sectionCountw = 1;

    // Loop through each child element
    Array.from(toc.children).forEach(child => {
        // Find the 'a' tag within the child element
        const link = child.querySelector('a');

        if (link) {
            // Clean up the href to remove conditional markers
            const href = link.getAttribute('href');
            if (href && href.includes('show_if')) {
                const cleanHref = href.replace(/-show_if[^-#]*$/i, '').replace(/-show_if[^#]*/, '');
                link.setAttribute('href', cleanHref);
            }
            
            // Create a span for the section number
            const span = document.createElement('span');
            span.textContent = sectionCountw; // Set the text content to the section number
            span.setAttribute('data-toc-step-number', 'true');
            span.className = 'toc-step-number';  // Keep class for CSS styling

            // Prepend the span to the 'a' tag
            link.prepend(span);

            // Increment the section count for the next child
            sectionCountw++;
        }
    });

  </script>
{% endblock %}
